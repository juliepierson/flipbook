# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Flipbook
                                 A QGIS plugin
 Create flipbook HTML animation by applying different styles to an input raster
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-02-22
        copyright            : (C) 2021 by Julie Pierson, UMR 6554 LETG, CNRS
        email                : julie.pierson@univ-brest.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Julie Pierson, UMR 6554 LETG, CNRS'
__date__ = '2021-02-22'
__copyright__ = '(C) 2021 by Julie Pierson, UMR 6554 LETG, CNRS'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from PyQt5.QtGui import (QImage,
                         QColor,
                         QPainter)
from PyQt5.QtCore import (QSize)
from qgis.core import (QgsProcessingAlgorithm,
                       QgsProcessingException,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterFile,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterFolderDestination,
                       QgsMapSettings,
                       QgsRectangle,
                       QgsMapRendererCustomPainterJob)
import os
import pandas as pd
from shutil import copyfile, copytree, rmtree
from PIL import Image
import webbrowser


class FlipbookAlgorithm(QgsProcessingAlgorithm):
    """
    This is an example algorithm that takes a vector layer and
    creates a new identical one.

    It is meant to be used as an example of how to create your own
    algorithms and explain methods and variables used to do it. An
    algorithm like this will be available in all elements, and there
    is not need for additional work.

    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    INPUT_RASTER = 'INPUT_RASTER'
    INPUT_CSV = 'INPUT_CSV'
    INPUT_COLOR_LIST = 'INPUT_COLOR_LIST'
    INPUT_IMG_WIDTH = 'INPUT_IMG_WIDTH'
    INPUT_IMG_HEIGHT = 'INPUT_IMG_HEIGHT'
    INPUT_SHADED_RELIEF = 'INPUT_SHADED_RELIEF'
    OUTPUT_FOLDER = 'OUTPUT_FOLDER'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # input DEM raster layer
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_RASTER,
                self.tr('Input DEM raster')
            )
        )
            
        # input CSV file
        self.addParameter(
            QgsProcessingParameterFile(
                self.INPUT_CSV,
                self.tr('Input csv file for color categories : 1st column for text description, next columns for categories limits (for ex., 3 limits define 2 categories)'),
                extension = "csv"
            )
        )
            
        # input color list
        self.addParameter(
            QgsProcessingParameterFile(
                self.INPUT_COLOR_LIST,
                self.tr('Input csv file for color list (i.e. 6 colors for 3 categories)'),
                extension = "csv"
            )
        )
            
        # output images width in pixels
        self.addParameter(
            QgsProcessingParameterNumber(
                self.INPUT_IMG_WIDTH,
                self.tr('width in pixels of output images, do not set if you want output to be roughly 800px wide'),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=None,
                optional=True,
                minValue=1,
                maxValue=5000
            )
        )
            
         # output images height in pixels
        self.addParameter(
            QgsProcessingParameterNumber(
                self.INPUT_IMG_HEIGHT,
                self.tr('height in pixels of output images, do not set if you want output to be roughly 800px wide'),
                type=QgsProcessingParameterNumber.Integer,
                defaultValue=None,
                optional=True,
                minValue=1,
                maxValue=5000
            )
        )
            
        # optional shaded relief raster
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.INPUT_SHADED_RELIEF,
                self.tr('Optional shaded relief raster'),
                optional=True
            )
        )
        
        # output folder for images
        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.OUTPUT_FOLDER, 
                self.tr('Output folder (preferably empty)'),
                defaultValue=None,
                optional=True
            )
        )
        

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """
        # Retrieve inputs and output
        input_raster = self.parameterAsRasterLayer(parameters, self.INPUT_RASTER, context)
        input_csv = self.parameterAsString(parameters, self.INPUT_CSV, context)
        input_colorlist = self.parameterAsString(parameters, self.INPUT_COLOR_LIST, context)
        input_shaded_relief = self.parameterAsRasterLayer(parameters, self.INPUT_SHADED_RELIEF, context)
        output_folder = self.parameterAsFile(parameters, self.OUTPUT_FOLDER, context)
        # input model for QML file
        qml_model = "qml/modele.qml"
        # animation folder model
        animation = "animation"
        # get input raster width and height in pixels
        img_width = self.parameterAsInt(parameters, self.INPUT_IMG_WIDTH, context)
        img_height = self.parameterAsInt(parameters, self.INPUT_IMG_HEIGHT, context)
        # if not set, output width must be roughly 800px
        if img_width == 0 or img_height == 0:
            div = input_raster.width()//800
            if div == 0:
                div = 1
            img_width = input_raster.width()/div
            img_height = input_raster.height()/div

        # LET'S GO !
        
        # check that color number matches categories number
        self.checkParameters(feedback, input_csv, input_colorlist)
        
        # create as many qml files as rows in input csv
        qml_list = self.createQmls(input_csv, qml_model, input_colorlist, output_folder)
        
        # for each qml file created precedingly
        for qml in qml_list:
            # apply qml style
            input_raster.loadNamedStyle(qml)
            #input_raster.triggerRepaint()
            # create image from input raster
            img = self.exportImage(input_raster, img_width, img_height)
            # save the image in same folder as qml files
            img_name = qml[:-4] + '.png'
            img.save(img_name)
        
        # create html/js animation
        self.createAnimation(animation, output_folder, img_width, img_height, qml_list)
        
        # create sprite image from output png images
        self.createSprite(output_folder)
        
        # if shaded relief is set
        if input_shaded_relief:
            # export it as png
            sr = self.exportImage(input_shaded_relief, img_width, img_height)
            sr.save(output_folder + '/animation/img/shaded_relief.png')
            # and set animation correspondingly
            self.setShadedRelief(output_folder)
            
        # open animation in web browser
        url = output_folder + '/animation/animation.html'
        webbrowser.open('file://' + url)
        
        return {}
        
        
    # checking input parameters
    def checkParameters(self, feedback, input_csv, input_colorlist):
        # get number of columns from input categories csv
        df1 = pd.read_csv(input_csv)
        nb_cat = len(df1.columns) - 2
        # get number of columns from input color csv
        df2 = pd.read_csv(input_colorlist)
        nb_colors = len(df2.columns)
        # check that it's coherent
        if nb_colors != nb_cat * 2:
            message = 'Color count does not match categories count, there should be one color per category, check plugin homepage for more details'
            #feedback.reportError(QCoreApplication.translate('Flipbook', message))
            raise QgsProcessingException(message)
            return {}
    
    
    # create qml files based upon csv and color list
    def createQmls(self, input_csv, qml_model, input_colorlist, output_folder):
        # create png directory in output folder to contain png and qml files
        os.makedirs(output_folder + '/png', exist_ok=True)
        # will contain list of qml files with their full path
        qml_list = []
        # convert input csv to panda dataframe
        df = pd.read_csv(input_csv)
        # convert first column (description) to string
        df.iloc[:,0] = df.iloc[:,0].astype(str)
        # for each csv line
        for index, row in df.iterrows():
            # get qml model path
            script_dir = os.path.dirname(__file__)
            qml_path = os.path.join(script_dir, qml_model)
            # get qml output path : qml will be named based upon 1st column of CSV input file
            output_qml = output_folder + '/png/' + str(row[0]) + '.qml'
            # add qml full path to list
            qml_list.append(output_qml)
            # create new qml file based upon model in output folder
            copyfile(qml_path, output_qml)
            # open this new qml file (this process is not optimized for big files)
            with open(output_qml, 'r') as qml:
                data = qml.readlines()
            # get index of line to copy
            datastrip = [line.strip() for line in data]
            indexline = datastrip.index('<!-- item -->')
            # duplicate all values in row except for first and last (without description = 1st column)
            newrow = [i for i in row[1:] for _ in (0, 1)]
            newrow = newrow[1:-1]
            # if comma is used for decimal separator, replaces it by dot and convert result to float
            newrow = [float(i.replace(',', '.')) if type(i) == str else i for i in newrow]
            # for each category limit :
            df_colors = pd.read_csv(input_colorlist)
            for i, color in enumerate(df_colors):
                # create line for this category limit
                newline = '<item label="{limitlabel}" color="{color}" alpha="255" value="{limit}"/>\n'.format(limitlabel = newrow[i], color = color, limit = newrow[i])
                # insert line just after last one
                data.insert(indexline + 1 + i, newline)
            # writes everything back in qml file
            with open(output_qml, 'w') as qml:
               qml.writelines(data)
        return qml_list
          
      
    # apply each QML file and export resulting images
    # https://opensourceoptions.com/blog/pyqgis-render-print-save-a-layer-as-an-image/
    def exportImage(self, input_raster, img_width, img_height):
        # create empty image
        img = QImage(QSize(img_width, img_height), QImage.Format_ARGB32_Premultiplied)
        # set background color
        color = QColor(255, 255, 255, 255)
        img.fill(color.rgba())
        # create painter
        p = QPainter()
        p.begin(img)
        p.setRenderHint(QPainter.Antialiasing)
        # create map settings
        ms = QgsMapSettings()
        ms.setBackgroundColor(color)
        # set layers to render
        ms.setLayers([input_raster])
        # set extent
        rect = QgsRectangle(ms.fullExtent())
        #rect.scale(1.1)
        ms.setExtent(rect)
        # set output size
        ms.setOutputSize(img.size())
        # setup qgis map renderer
        render = QgsMapRendererCustomPainterJob(ms, p)
        render.start()
        render.waitForFinished()
        p.end()
        # return image
        return img
    
        
    # create html/js animation
    def createAnimation(self, animation, output_folder, img_width, img_height, qml_list):
        # get animation folder path
        script_dir = os.path.dirname(__file__)
        animation_path = os.path.join(script_dir, animation)
        # if animation folder already exists, delete it
        if os.path.exists(output_folder + '/animation'):
            rmtree(output_folder + '/animation', ignore_errors=True)
        # copy animation model folder in output folder
        copytree(animation_path, (output_folder + '/animation'))
        # get number of images
        nbFrames = len(qml_list)
        # replaces values in html, js and css files
        file_list = ['animation.html', 'js/script.js', 'css/style.css']
        file_list = [output_folder + '/animation/' + anim_file for anim_file in file_list]
        for anim_file in file_list:
            # read in the file
            with open(anim_file, 'r') as file :
                filedata = file.read()
            # replace all target strings
            filedata = filedata.replace('**nbFrames**', str(nbFrames-1))
            filedata = filedata.replace('**frameHeight**', str(img_height))
            filedata = filedata.replace('**frameWidth**', str(img_width))
            # write the file out again
            with open(anim_file, 'w') as file:
                file.write(filedata)
  
              
    # create sprite for animation from png images : all png are stacked vertically
    def createSprite(self, output_folder):
        # get list of png full paths
        png_list = [f for f in os.listdir(output_folder + '/png') if f.endswith('.png')]
        png_list = [output_folder + '/png/' + png for png in png_list]
        # get full path of future output jpg
        output_jpg = output_folder + '/animation/img/sprite.jpg'
        # open all images with PIL module
        images = [Image.open(x) for x in png_list]
        # create new images with wanted dimensions
        widths, heights = zip(*(i.size for i in images))
        total_height = sum(heights)
        width = max(widths)
        new_img = Image.new('RGB', (width, total_height))
        # add each png under the preceding one
        y_offset = 0
        for img in images:
          new_img.paste(img, (0, y_offset))
          y_offset += img.size[1]
        # save as jpg
        new_img.save(output_jpg)
    
    
    def setShadedRelief(self, output_folder):
        # img tag for shaded relief
        img_sr = '<img class="shaded_relief" src="img/shaded_relief.png" alt="shaded relief">'
        # uncomment img for shaded relief in html file
        html_file = output_folder + '/animation/animation.html'
        with open(html_file, 'r') as file :
            filedata = file.read()
        filedata = filedata.replace('<!-- shaded relief -->', img_sr)
        with open(html_file, 'w') as file:
            file.write(filedata)
        # set opacity for DEM in css to 0.5 so that shaded relief is visible
        css_file = output_folder + '/animation/css/style.css'
        with open(css_file, 'r') as file :
            filedata = file.read()
        filedata = filedata.replace('opacity: 1;', 'opacity: 0.5;')
        with open(css_file, 'w') as file:
            file.write(filedata)


    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'Flipbook'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return FlipbookAlgorithm()
